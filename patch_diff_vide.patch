diff --git a/crates/cli/src/main.rs b/crates/cli/src/main.rs
@@
-fn collect_context(path: &str) -> Result<String>
-{
-    // MVP: naive â€” list a few files with content; later: git-aware, size limits
-    let mut out = String::new();
-    for entry in walkdir::WalkDir::new(path).max_depth(2) {
-        let entry = entry?;
-        if entry.file_type().is_file() {
-            let p = entry.path().display().to_string();
-            if p.ends_with(".rs") || p.ends_with("Cargo.toml") {
-                if let Ok(content) = std::fs::read_to_string(entry.path()) {
-                    out.push_str(&format!("\n>>> FILE: {}\n{}\n", p, content));
-                }
-            }
-        }
-    }
-    Ok(out)
-}
+fn collect_context(path: &str) -> Result<String> {
+    use std::fs;
+    let mut out = String::new();
+    let max_depth = 3usize;
+    let max_files = 50usize;
+    let max_bytes = 250_000usize; // ~250 KB de contexte total
+    let mut total_bytes = 0usize;
+    let mut count = 0usize;
+
+    fn relevant(p: &str) -> bool {
+        let p = p.to_lowercase();
+        // Langages & config courants SWE-bench (majoritairement Python)
+        p.ends_with(".py")
+            || p.ends_with(".pyi")
+            || p.ends_with("pyproject.toml")
+            || p.ends_with("setup.py")
+            || p.ends_with("setup.cfg")
+            || p.ends_with("requirements.txt")
+            || p.ends_with("requirements-dev.txt")
+            || p.ends_with("tox.ini")
+            || p.ends_with("pytest.ini")
+            || p.ends_with("conftest.py")
+            || p.ends_with("README.md")
+            || p.ends_with(".editorconfig")
+            || p.ends_with(".flake8")
+            || p.ends_with(".pylintrc")
+            || p.ends_with(".ruff.toml")
+            || p.ends_with("mypy.ini")
+            // On garde aussi le Rust (si projet mixte)
+            || p.ends_with(".rs")
+            || p.ends_with("cargo.toml")
+    }
+
+    for entry in walkdir::WalkDir::new(path).max_depth(max_depth) {
+        let entry = entry?;
+        if !entry.file_type().is_file() { continue; }
+        let p = entry.path();
+        let ps = p.display().to_string();
+        if !relevant(&ps) { continue; }
+        if count >= max_files || total_bytes >= max_bytes { break; }
+        if let Ok(content) = fs::read_to_string(p) {
+            let remaining = max_bytes.saturating_sub(total_bytes);
+            if remaining == 0 { break; }
+            let clipped = if content.len() > remaining {
+                // coupe proprement sur boundary des chars UTF-8
+                content.chars().take(remaining).collect::<String>()
+            } else {
+                content
+            };
+            total_bytes += clipped.len();
+            count += 1;
+            out.push_str(&format!("\n>>> FILE: {}\n{}\n", ps, clipped));
+        }
+    }
+    Ok(out)
+}

