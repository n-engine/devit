========================
Directives Codex — Ticket B : Validation JSON I/O (devit.tool_call, plugin.invoke)

Objectif: refuser tôt les entrées mal formées avec messages clairs.

Schémas minimaux:

devit.tool_call: requis tool: string, args: object

plugin.invoke: requis id: string, payload: object

Emplacement:

mcp_server.rs, juste avant exécution (après approvals/ratelimit/dry-run)

Erreur normalisée:
tool.error { schema_error:true, path:"payload.tool" | "payload.args" | "payload.id" | "payload.payload", reason:"missing|type_mismatch" }

Tests:

manquant → missing

mauvais type → type_mismatch

ok → passe à l’exécution réelle

========================
Directives Codex — Ticket C : Profils d’approvals (safe|std|danger)

Objectif: activer un preset en 1 ligne dans .devit/devit.toml, surchargeable par outils.

Config:
[ mcp ]
profile = "safe" | "std" | "danger"
approvals = { ... } # overrides spécifiques

Presets:

safe: devit.tool_call=on_request, plugin.invoke=on_request, server.*=never

std: devit.tool_call=on_failure, plugin.invoke=on_request, server.*=never

danger: devit.tool_call=never, plugin.invoke=on_failure, server.*=never

Chargement:

appliquer profile → puis appliquer approvals{} explicites

--policy-dump inclut "profile": "<nom>"

Tests:

safe: plugin.invoke sans --yes → approval_required

std: devit.tool_call échoue → post-failure approval_required

danger: devit.tool_call passe direct

========================
Directives Codex — Ticket D : Provenance git (footer + notes)

Objectif: attester minimalement les actions DevIt.

Config:
[ provenance ]
footer = true
[ git ]
use_notes = true

Attestation:

hash = HMAC(hmac.key, concat(tool_name, sha256(args_json), timestamp_ms))

si footer=true → ajouter “\n\nDevIt-Attest: <hash>” aux commits générés par DevIt

si git.use_notes=true → git notes add -m "DevIt-Attest: <hash>"

Erreurs:

si git non dispo → ignorer note (logguer dans audit), ne pas échouer l’action

Tests:

commit généré → footer présent

git notes show <commit> → contient DevIt-Attest si activé

========================
Commandes de test (texte brut)

cargo fmt --all -- --check
cargo clippy --workspace --all-targets -- -D warnings
cargo test --workspace --all-targets --no-fail-fast -- --nocapture

E2E MCP minimal

make e2e-mcp

Manifest plugin (exemple)

echo '{"id":"echo_sum","payload":{"a":2,"b":40}}' | target/debug/devit-mcp --cmd 'target/debug/devit-mcpd --yes' --call plugin.invoke --json @-

Politiques

target/debug/devit-mcp --cmd 'target/debug/devit-mcpd --policy-dump' | jq

Provenance (visuel)

git log -1 --pretty=%B | rg 'DevIt-Attest:' || true
git notes show HEAD || true

Planning 7 jours (2h/j)

Jour 1 (2h) — Ticket A (manifest)

Codex: parse/validate manifest + préouvertures wasmtime

ToDo: happy path + 2 KO

Olivier: tester echo_sum manifesté

Jour 2 (2h) — Ticket B (validation JSON)

Codex: schémas + erreurs normalisées

Olivier: 3 cas invalides + 1 valide via devit-mcp

Jour 3 (2h) — Ticket C (profils)

Codex: profil + merge + policy_dump

Olivier: basculer safe/std/danger, vérifier comportements

Jour 4 (2h) — Ticket D (provenance)

Codex: footer + git notes (optionnel)

Olivier: vérifier footer/note sur un commit DevIt

Jour 5 (2h) — Docs & CI léger

Codex: README sections Plugins/Contexte/MCP, CONTRIBUTING updates

CI: job plugins_manifest_check (lint toml + build wasm exemple)

Olivier: relire, corriger 2-3 tournures

Jour 6 (2h) — Durcissement rapide

Cap erreur homogènes (timeout=124, dry-run deny, schema_error, rate_limited)

Make lint-flags + scripts/lint_errors.sh à jour

Olivier: make e2e-mcp + lint scripts

Jour 7 (2h) — Freeze v0.2-rc.3 → v0.2 finale

Bump versions, release notes, tags

Sanity: policy/health/stats/context_head OK

Definition of Done (v0.2 final)

Tous les jobs CI “required” verts (fmt, clippy, tests, e2e-mcp, lint_meta, manifest_check)

server.* stables; erreurs normalisées; profils actifs; provenance activable

README/CONTRIBUTING à jour; exemples reproduisibles

Risques → atténuations

Manque de temps: tickets A et B suffisent pour un vrai palier sécurité → livrer même si C/D glissent.

Différences d’état repo: éviter renames; garder directives textuelles; tests end-to-end courts.

wasmtime indispo CI: rendre le job plugin E2E facultatif (skip si absent).
