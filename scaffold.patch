diff --git a/crates/cli/Cargo.toml b/crates/cli/Cargo.toml
index 1111111..2222222 100644
--- a/crates/cli/Cargo.toml
+++ b/crates/cli/Cargo.toml
@@ -1,6 +1,23 @@
 [package]
 name = "devit-cli"
 version = "0.2.0"
 edition = "2021"
 
+[features]
+# Aucun impact par défaut. Active les bins/commandes MCP.
+default = []
+experimental = []
+
 [[bin]]
 name = "devit"
 path = "src/main.rs"
+
+# Binaire expérimental MCP (n'est compilé que si feature activée)
+[[bin]]
+name = "devit-mcp"
+path = "src/bin/devit-mcp.rs"
+required-features = ["experimental"]
+
+[dependencies]
+anyhow = "1"
+serde = { version = "1", features = ["derive"] }
+serde_json = "1"
diff --git a/crates/cli/src/mcp.rs b/crates/cli/src/mcp.rs
new file mode 100644
index 0000000..a1b2c3d
--- /dev/null
+++ b/crates/cli/src/mcp.rs
@@ -0,0 +1,421 @@
+// MCP client minimal (stdio) — expérimental.
+// - Handshake: ping -> version -> capabilities
+// - Tool call démo: echo
+// - Timeouts via DEVIT_TIMEOUT_SECS (par message)
+//
+// Ce module est consommé par le binaire `devit-mcp` uniquement.
+
+use anyhow::{anyhow, Context, Result};
+use serde::{Deserialize, Serialize};
+use serde_json::{json, Value};
+use std::env;
+use std::io::{BufRead, BufReader, BufWriter, Write};
+use std::process::{Child, ChildStdin, ChildStdout, Command, Stdio};
+use std::sync::mpsc;
+use std::thread;
+use std::time::Duration;
+
+pub fn timeout_from_env() -> Duration
+{
+    let secs = env::var("DEVIT_TIMEOUT_SECS")
+        .ok()
+        .and_then(|s| s.parse::<u64>().ok())
+        .unwrap_or(30);
+    Duration::from_secs(secs)
+}
+
+#[derive(Debug, Clone, Serialize, Deserialize)]
+pub struct Capabilities
+{
+    pub tools: Vec<String>,
+}
+
+#[derive(Debug)]
+pub struct McpClient
+{
+    child: Child,
+    stdin: BufWriter<ChildStdin>,
+    stdout: BufReader<ChildStdout>,
+    per_msg_timeout: Duration,
+}
+
+impl McpClient
+{
+    pub fn spawn_cmd(cmd: &str, per_msg_timeout: Duration) -> Result<Self>
+    {
+        // On passe par bash -lc pour supporter des pipelines/quoted.
+        let mut child = Command::new("bash")
+            .arg("-lc")
+            .arg(cmd)
+            .stdin(Stdio::piped())
+            .stdout(Stdio::piped())
+            .stderr(Stdio::inherit())
+            .spawn()
+            .with_context(|| format!("spawn failed for: {cmd}"))?;
+
+        let stdin = BufWriter::new(
+            child.stdin.take().ok_or_else(
+                || anyhow!("child stdin missing"),
+            )?,
+        );
+        let stdout = BufReader::new(
+            child.stdout.take().ok_or_else(
+                || anyhow!("child stdout missing"),
+            )?,
+        );
+        Ok(Self {
+            child,
+            stdin,
+            stdout,
+            per_msg_timeout,
+        })
+    }
+
+    pub fn handshake(
+        &mut self,
+        client_version: &str,
+    ) -> Result<Capabilities>
+    {
+        // 1) ping -> pong
+        self.write_json(&json!({ "type": "ping" }))?;
+        let pong = self.read_json_line_timeout()?;
+        ensure_type(&pong, "pong")?;
+
+        // 2) version exchange
+        self.write_json(&json!({
+            "type": "version",
+            "payload": { "client": client_version }
+        }))?;
+        let ver = self.read_json_line_timeout()?;
+        ensure_type(&ver, "version")?;
+
+        // 3) capabilities
+        self.write_json(&json!({ "type": "capabilities" }))?;
+        let caps = self.read_json_line_timeout()?;
+        ensure_type(&caps, "capabilities")?;
+        let tools = caps
+            .get("payload")
+            .and_then(|p| p.get("tools"))
+            .and_then(|t| t.as_array())
+            .ok_or_else(|| anyhow!("invalid capabilities payload"))?
+            .iter()
+            .filter_map(|v| v.as_str().map(str::to_string))
+            .collect::<Vec<_>>();
+        Ok(Capabilities { tools })
+    }
+
+    pub fn tool_echo(&mut self, text: &str) -> Result<Value>
+    {
+        self.write_json(&json!({
+            "type": "tool.call",
+            "payload": { "name": "echo", "args": { "text": text } }
+        }))?;
+        let v = self.read_json_line_timeout()?;
+        ensure_type(&v, "tool.result")?;
+        Ok(v)
+    }
+
+    fn write_json(&mut self, v: &Value) -> Result<()>
+    {
+        let s = serde_json::to_string(v)?;
+        self.stdin.write_all(s.as_bytes())?;
+        self.stdin.write_all(b"\n")?;
+        self.stdin.flush()?;
+        Ok(())
+    }
+
+    fn read_json_line_timeout(&mut self) -> Result<Value>
+    {
+        let (tx, rx) = mpsc::sync_channel::<Result<String>>(1);
+        let timeout = self.per_msg_timeout;
+        // On clone un pointeur vers un *mutable borrow* n'est pas
+        // possible; on lit depuis un thread avec un bloc scope.
+        let mut reader = self.stdout.by_ref().lines();
+        thread::spawn(move || {
+            let res = reader.next()
+                .ok_or_else(|| anyhow!("eof from server"))
+                .and_then(|r| r.map_err(|e| anyhow!(e)));
+            let _ = tx.send(res);
+        });
+        let line = rx.recv_timeout(timeout)
+            .map_err(|_| anyhow!("timeout waiting line"))??;
+        let v: Value = serde_json::from_str(&line)
+            .with_context(|| format!("invalid json: {line}"))?;
+        Ok(v)
+    }
+}
+
+fn ensure_type(v: &Value, expected: &str) -> Result<()>
+{
+    let t = v.get("type")
+        .and_then(|x| x.as_str())
+        .ok_or_else(|| anyhow!("missing type"))?;
+    if t != expected
+    {
+        Err(anyhow!("unexpected type: {t}, want {expected}"))
+    }
+    else
+    {
+        Ok(())
+    }
+}
+
+#[cfg(test)]
+mod tests
+{
+    use super::*;
+    use std::io::Cursor;
+
+    // Test logique: enchaîne les JSON attendus sans vrai sous-processus.
+    // On simule stdout serveur; on ignore spawn ici.
+    struct Fake
+    {
+        out: BufReader<Cursor<Vec<u8>>>,
+        inp: Vec<u8>,
+        timeout: Duration,
+    }
+
+    impl Fake
+    {
+        fn new(server_lines: &[&str]) -> Self
+        {
+            let joined = server_lines
+                .iter()
+                .map(|s| format!("{s}\n"))
+                .collect::<String>()
+                .into_bytes();
+            Self {
+                out: BufReader::new(Cursor::new(joined)),
+                inp: Vec::new(),
+                timeout: Duration::from_millis(200),
+            }
+        }
+
+        fn read_json_line_timeout(&mut self) -> Result<Value>
+        {
+            let (tx, rx) = mpsc::sync_channel::<Result<String>>(1);
+            let timeout = self.timeout;
+            // reader local emprunté mut.
+            let mut reader = self.out.by_ref().lines();
+            thread::spawn(move || {
+                let res = reader.next()
+                    .ok_or_else(|| anyhow!("eof from server"))
+                    .and_then(|r| r.map_err(|e| anyhow!(e)));
+                let _ = tx.send(res);
+            });
+            let line = rx.recv_timeout(timeout)
+                .map_err(|_| anyhow!("timeout waiting line"))??;
+            let v: Value = serde_json::from_str(&line)?;
+            Ok(v)
+        }
+
+        fn write_json(&mut self, v: &Value) -> Result<()>
+        {
+            let s = serde_json::to_string(v)?;
+            self.inp.extend_from_slice(s.as_bytes());
+            self.inp.extend_from_slice(b"\n");
+            Ok(())
+        }
+    }
+
+    #[test]
+    fn ensure_type_ok()
+    {
+        let v = json!({"type":"pong"});
+        assert!(ensure_type(&v, "pong").is_ok());
+    }
+
+    #[test]
+    fn ensure_type_bad()
+    {
+        let v = json!({"type":"nope"});
+        assert!(ensure_type(&v, "pong").is_err());
+    }
+
+    #[test]
+    fn handshake_flow_happy_path()
+    {
+        let mut fake = Fake::new(&[
+            r#"{"type":"pong"}"#,
+            r#"{"type":"version","payload":{"server":"mock"}}"#,
+            r#"{"type":"capabilities","payload":{"tools":["echo"]}}"#,
+        ]);
+
+        // ping
+        fake.write_json(&json!({"type":"ping"})).unwrap();
+        let pong = fake.read_json_line_timeout().unwrap();
+        ensure_type(&pong, "pong").unwrap();
+
+        // version
+        fake.write_json(&json!({"type":"version","payload":{"client":"x"}}))
+            .unwrap();
+        let ver = fake.read_json_line_timeout().unwrap();
+        ensure_type(&ver, "version").unwrap();
+
+        // capabilities
+        fake.write_json(&json!({"type":"capabilities"})).unwrap();
+        let caps = fake.read_json_line_timeout().unwrap();
+        ensure_type(&caps, "capabilities").unwrap();
+        let tools = caps["payload"]["tools"].as_array().unwrap();
+        assert_eq!(tools[0], "echo");
+    }
+
+    #[test]
+    fn read_timeout_errors()
+    {
+        // Pas de lignes -> timeout
+        let mut fake = Fake::new(&[]);
+        let r = fake.read_json_line_timeout();
+        assert!(r.is_err());
+    }
+}
diff --git a/crates/cli/src/bin/devit-mcp.rs b/crates/cli/src/bin/devit-mcp.rs
new file mode 100644
index 0000000..d4e5f6a
--- /dev/null
+++ b/crates/cli/src/bin/devit-mcp.rs
@@ -0,0 +1,199 @@
+//! CLI expérimentale MCP (stdio).
+//! Construite uniquement avec: --features experimental
+//! Usage:
+//!   devit-mcp --cmd '<serveur MCP>' [--handshake-only]
+//!   devit-mcp --cmd '<serveur MCP>' --echo "hello"
+
+use clap::{ArgAction, Parser};
+use devit_cli_mcp as mcp_mod;
+
+// Import du module `src/mcp.rs` depuis un binaire secondaire.
+#[path = "../mcp.rs"]
+mod devit_cli_mcp;
+
+use anyhow::{anyhow, Context, Result};
+use serde_json::json;
+use std::time::Duration;
+
+#[derive(Parser, Debug)]
+#[command(name = "devit-mcp")]
+#[command(about = "Client MCP stdio (expérimental)")]
+struct Cli
+{
+    /// Commande à lancer (serveur MCP, via bash -lc)
+    #[arg(long)]
+    cmd: String,
+
+    /// Handshake seulement (ping/version/capabilities)
+    #[arg(long, action = ArgAction::SetTrue)]
+    handshake_only: bool,
+
+    /// Tool echo: envoie un appel avec {text}
+    #[arg(long)]
+    echo: Option<String>,
+
+    /// Dry-run: n'exécute pas la commande, affiche juste le plan
+    #[arg(long, action = ArgAction::SetTrue)]
+    dry_run: bool,
+
+    /// Timeout par message (secs). Par défaut: DEVIT_TIMEOUT_SECS ou 30
+    #[arg(long)]
+    timeout_secs: Option<u64>,
+
+    /// Version client à annoncer
+    #[arg(long, default_value = "0.2.0-rc.1")]
+    client_version: String,
+}
+
+fn main()
+{
+    if let Err(e) = real_main()
+    {
+        eprintln!("error: {e:?}");
+        std::process::exit(2);
+    }
+}
+
+fn real_main() -> Result<()>
+{
+    let cli = Cli::parse();
+    let timeout = timeout(cli.timeout_secs);
+
+    if cli.dry_run
+    {
+        println!(
+            "{{\"dry_run\":true,\"cmd\":{cmd},\"timeout_secs\":{t},\
+             \"handshake_only\":{h},\"echo\":{echo}}}",
+            cmd = serde_json::to_string(&cli.cmd)?,
+            t = timeout.as_secs(),
+            h = cli.handshake_only,
+            echo = serde_json::to_string(&cli.echo)?,
+        );
+        return Ok(());
+    }
+
+    let mut client = mcp_mod::McpClient::spawn_cmd(&cli.cmd, timeout)
+        .with_context(|| "spawn MCP server failed")?;
+
+    let caps = client.handshake(&cli.client_version)
+        .with_context(|| "handshake failed")?;
+    println!("{}", serde_json::to_string(&json!({
+        "type": "handshake.ok",
+        "payload": { "tools": caps.tools }
+    }))?);
+
+    if cli.handshake_only
+    {
+        return Ok(());
+    }
+
+    if let Some(text) = cli.echo.as_deref()
+    {
+        let r = client.tool_echo(text)
+            .with_context(|| "echo call failed")?;
+        println!("{}", serde_json::to_string(&r)?);
+        return Ok(());
+    }
+
+    Err(anyhow!("nothing to do: pass --handshake-only or --echo"))
+}
+
+fn timeout(override_secs: Option<u64>) -> Duration
+{
+    if let Some(s) = override_secs
+    {
+        return Duration::from_secs(s);
+    }
+    mcp_mod::timeout_from_env()
+}

