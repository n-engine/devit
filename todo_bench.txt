OBJECTIF
Corriger le dossier bench/ pour que la génération de predictions.jsonl fonctionne sur SWE-bench_Lite et lancer un smoke test local (1–10 instances). Le pipeline doit aboutir même si les diffs sont vides (but : valider bout-à-bout).

CONTEXTE RAPIDE

Projet: DevIt (Rust, CLI).

bench/generate_predictions.py charge princeton-nlp/SWE-bench_Lite, mais mes IDs n’étaient pas dans le split → predictions.jsonl vide.

On veut:

charger les bons IDs depuis le dataset,

construire le goal avec title + problem_statement + hints_text,

appeler DevIt via binaire (DEVIT_BIN) ou cargo run (DEVIT_REPO),

supporter un chemin de config unique (DEVIT_CONFIG),

ajouter un mode --allow-empty qui écrit quand même une ligne dans predictions.jsonl si le diff est vide (utile pour le smoke test),

lancer le harness officiel sur 1–2 instances.

À FAIRE (modifs de code et scripts)

bench/generate_predictions.py

Assurer Python 3.10+ (si besoin remplacer str | None par Optional[str]).

Mettre à jour la fonction run(cmd, cwd=None, check=True, env=None) pour supporter env (appel à subprocess.run(..., env=env)).

Paramètres CLI à ajouter ou confirmer:

--devit-bin (chemin binaire DevIt) et/ou DEVIT_BIN.

--devit-config (chemin vers devit.toml) et/ou DEVIT_CONFIG.

--dataset (par défaut princeton-nlp/SWE-bench_Lite).

--split (par défaut test).

--limit (pour n’échantillonner que N instances, ex: 10).

--allow-empty (si diff vide, on écrit quand même une entrée avec model_patch = chaîne vide ou un patch bidon — cf. point plus bas).

Fonction resolve_devit_cmd() : ordre de priorité

--devit-bin → binaire exécutable

DEVIT_BIN → binaire exécutable

DEVIT_REPO → utiliser ["cargo","run","-p","devit","--"] avec cwd=DEVIT_REPO

sinon devit dans le PATH

build_goal(record) : concaténer title, problem_statement, hints_text s’il existe (le champ hints n’existe pas dans Lite).

devit_suggest(goal, cwd, devit_bin, devit_config) :

passer env["DEVIT_CONFIG"]=... si fourni,

exécuter devit suggest --goal "<goal>" <cwd>,

retourner stdout.strip().

Chargement dataset: ds = load_dataset(args.dataset, split=args.split); constituer un index instance_id → record.

Lecture des instances: si --instances non fourni, auto-créer instances_auto_<limit>.txt en prenant les instance_id des limit premiers exemples du split.

Lors de la boucle : si diff == "" et --allow-empty, écrire une ligne JSONL quand même avec model_patch: "" (ou un minuscule patch bidon). Sinon, sauter mais logger [WARN] empty diff.

Chaque ligne JSONL doit contenir :

{"instance_id": "...", "model_name_or_path": "devit-local", "model_patch": "<unified diff or empty>"}


bench/eval.sh

Permettre de passer le nombre de workers via 3e argument (WORKERS, défaut 1) ou variable d’env WORKERS.

Appeler:

python -m swebench.harness.run_evaluation \
  --dataset_name princeton-nlp/SWE-bench_Lite \
  --predictions_path "$PRED" \
  --max_workers "${WORKERS:-1}" \
  --run_id "$RUN_ID"


Config unique pour le bench

Créer bench/devit.bench.toml si absent (approval=never, sandbox=workspace-write, backend local).

Le script doit transmettre DEVIT_CONFIG pour chaque appel à DevIt.

Commandes utilitaires

Ajouter une cible “smoke” dans bench/README.md :

# build devit
cargo build -p devit --release
export DEVIT_BIN="$PWD/target/release/devit"
export DEVIT_CONFIG="$PWD/bench/devit.bench.toml"
export DEVIT_BACKEND_URL="http://localhost:1234/v1"  # ou 11434/v1 pour Ollama
export DEVIT_TIMEOUT_SECS=120

# générer automatiquement 5 IDs du split test si le fichier n'existe pas
python - <<'PY'
from datasets import load_dataset
ds = load_dataset('princeton-nlp/SWE-bench_Lite', split='test')
with open('bench/instances_auto_5.txt','w') as f:
    for iid in ds.select(range(5))['instance_id']:
        print(iid, file=f)
PY

# génération des prédictions (allow-empty pour smoke)
cd bench
python generate_predictions.py \
  --instances instances_auto_5.txt \
  --output predictions.jsonl \
  --workdir ./workspaces \
  --devit-bin "$DEVIT_BIN" \
  --devit-config "$DEVIT_CONFIG" \
  --dataset princeton-nlp/SWE-bench_Lite \
  --split test \
  --limit 5 \
  --allow-empty

# évaluation sur 1 worker
bash eval.sh predictions.jsonl devit_lite_smoke 1


ACCEPTANCE CRITERIA (à vérifier automatiquement)

python bench/generate_predictions.py ... crée un predictions.jsonl non vide (≥ 1 ligne), même si les diffs sont vides quand --allow-empty est passé.

bash bench/eval.sh predictions.jsonl devit_lite_smoke 1 s’exécute jusqu’au bout (pas de crash du harness). Le résultat peut afficher 0 résolus, c’est OK pour le smoke test.

Les logs affichent pour la première instance :

le instance_id utilisé,

la longueur du goal construit,

si diff vide ou non.

Les chemins DevIt sont correctement résolus via --devit-bin ou DEVIT_REPO; DEVIT_CONFIG est utilisé par DevIt (vérifier en ajoutant un log côté DevIt si nécessaire).

DÉBOGAGE (si ça coince encore)

Imprimer print("DEVIT_BIN=", args.devit_bin, "DEVIT_REPO=", os.environ.get("DEVIT_REPO"), "PATH has devit:", shutil.which("devit")).

Afficher un extrait du goal (goal[:200]) pour la première instance.

Si diff est vide trop souvent, logguer le returncode et stderr de l’appel DevIt, et écrire un fichier workspaces/<repo>/code/.devit-goal.txt pour post-mortem.

Forcer --limit 1 pour accélérer le smoke.

COMMIT MESSAGES (Conventional)

feat(bench): support DEVIT_CONFIG, --split/--limit/--allow-empty; fix env passing

chore(bench): eval.sh allow workers arg; add smoke instructions

DELIVERABLES

bench/generate_predictions.py mis à jour (avec les options ci-dessus).

bench/eval.sh mis à jour (3e arg WORKERS).

bench/devit.bench.toml présent.

bench/README.md enrichi avec la procédure smoke.

predictions.jsonl généré (≥ 1 ligne) + sortie du harness sur 1 instance.
